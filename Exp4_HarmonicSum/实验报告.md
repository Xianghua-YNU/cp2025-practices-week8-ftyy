# 实验四：调和级数求和顺序与舍入误差实验报告

## 1. 实验目的
1. 实现并比较两种调和级数求和方法
2. 量化分析不同求和顺序导致的计算结果差异
3. 理解浮点数舍入误差的累积效应
4. 探究求和顺序对数值计算精度的影响

## 2. 实验原理
### 2.1 调和级数部分和
调和级数的前N项和定义为：

$$ S_N = \sum_{n=1}^{N} \frac{1}{n} $$

### 2.2 两种求和方法
1. 从小到大求和（ $S^{(up)}$）：

$$ S^{(up)} = \sum_{n=1}^{N}\frac{1}{n} = \frac{1}{1} + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{N} $$

2. 从大到小求和（ $S^{(down)}$）：

$$ S^{(down)} = \sum_{n=N}^{1}\frac{1}{n} = \frac{1}{N} + \frac{1}{N-1} + \cdots + \frac{1}{2} + \frac{1}{1} $$

### 2.3 相对差异计算
两种方法的相对差异定义为：

$$ \delta = \frac{|S^{(up)} - S^{(down)}|}{|(S^{(up)} + S^{(down)}) / 2|} $$

## 3. 实验方法
### 3.1 代码实现
- 实现 `sum_up(N)` 函数，从小到大计算调和级数和
- 实现 `sum_down(N)` 函数，从大到小计算调和级数和

### 3.2 数据收集
对不同的N值进行计算：
1. N值选取：使用 `np.logspace(1, 4, 50)` 在对数尺度上均匀取点
2. 计算并记录相对差异

## 4. 实验结果
### 4.1 数据记录

| N | $S^{(up)}$ | $S^{(down)}$ | 相对差异 δ |
|---|------------|--------------|------------|
|10       | 2.9289682540     |   2.9289682540   |     0.0000000000e+00    
|100       |5.1873775176      |  5.1873775176    |    1.7121915972e-16    
|1000      |7.4854708606       | 7.4854708606     |   3.5596094204e-16    
|10000     |9.7876060360        |9.7876060360      |  3.8112990541e-15    
|100000    |12.0901461299       |12.0901461299      | 6.0239660988e-15    

### 4.2 误差分析图
![image](https://github.com/user-attachments/assets/7a2d4a9b-09c1-40ce-b547-f52e0561564a)


## 5. 分析与讨论
### 5.1 结果分析
1. 相对差异随N的变化趋势：
   
相对差异随着 ( N ) 的增大而逐渐增大。
在 ( N ) 较小时（如 ( N < 100 )），相对差异接近零，说明两种求和方法的结果几乎一致。
当 ( N ) 增大到 ( 10^4 ) 或更大时，相对差异开始显著增加，表明舍入误差的累积效应变得明显。

2. 舍入误差累积效应：
   - （分析为什么 $S^{(down)}$更精确）

从大到小求和时，较大的数先被累加，较小的数在后续被加上时，其相对误差较小。避免了小数部分的舍入损失。
从小到大求和时，较小的数先被累加，后续较大的数会掩盖较小数的贡献，导致舍入误差更大。

### 5.2 误差来源分析
1. 浮点数表示精度限制

浮点数在计算机中是以有限位数表示的，通常是 32 位或 64 位。
这种有限精度导致在表示非常小的数时可能出现舍入误差。
当 ( N ) 增大时，调和级数的和 ( S_N ) 也增大，较小的项（如 ($\frac{1}{N}$）在浮点数表示中可能被舍入为零。

2. 加法运算中的舍入

浮点数加法运算会引入舍入误差，尤其是当两个数的数量级相差较大时。
从小到大求和时，较小的数先被累加，累加和逐渐变大，后续的小数部分容易被舍入掉。
从大到小求和时，较大的数先被累加，避免了小数部分的舍入损失。

3. 求和顺序的影响
求和顺序直接影响舍入误差的累积方式：
从小到大求和时，舍入误差会逐步累积，最终导致较大的误差。
从大到小求和时，较大的数先被累加，舍入误差较小，结果更精确。

## 6. 结论

相对差异随 ( N ) 的变化：

实验结果表明，相对差异随着 ( N ) 的增大而逐渐增大。
在 ( N ) 较小时（如 ( N < 100 )），两种求和方法的结果几乎一致，说明舍入误差的影响较小。
当 ( N ) 增大到 ( 10^4 ) 或更大时，从小到大求和的误差显著增大，而从大到小求和的结果仍然保持较高的精度。

从大到小求和更精确：

从大到小求和时，较大的数先被累加，较小的数在后续被加上时，其相对误差较小。
从小到大求和时，较小的数先被累加，累加和逐渐变大，后续的小数部分容易被舍入掉，导致误差更大。

## 7. 思考题
1. 为什么从大到小求和通常能获得更好的精度？

舍入误差的累积效应：

浮点数在计算机中是以有限精度表示的，通常遵循 IEEE 754 标准。当一个非常小的数加到一个非常大的数上时，小数部分可能被舍入掉，导致精度损失。

从大到小求和时，较大的数先被累加，累加和的数量级较大，后续较小的数被加上时，其相对误差较小。

从小到大求和时，较小的数先被累加，累加和逐渐变大，后续的小数部分容易被舍入掉，导致误差逐步累积。

2. 在实际应用中，如何选择合适的求和策略来减小舍入误差？

优先选择从大到小的求和顺序：

对于累加和问题，优先选择从大到小的求和顺序，以减少舍入误差的累积。

分块求和：

将求和任务分成多个小块，在每个小块中分别求和，然后再将小块的结果累加。这种方法可以减少舍入误差的传播。

Kahan 求和算法：

使用 Kahan 求和算法（或其改进版本）可以显著减少舍入误差。该算法通过引入一个补偿变量，跟踪舍入误差并在后续计算中进行修正。

高精度数据类型：

在需要极高精度的场景下，可以使用高精度数据类型（如 Python 的 decimal 模块）或多精度库（如 mpmath）。

自适应算法：

根据数据的分布情况动态调整求和顺序。例如，对于数据中较大的数，可以优先处理以减少误差。

3. 除了改变求和顺序，还有什么方法可以提高数值计算的精度？

使用高精度浮点数：

使用高精度浮点数（如 128 位浮点数）可以显著提高计算精度，但会增加计算成本。

变量代换：

在某些情况下，可以通过变量代换将问题转化为更适合数值计算的形式。例如，对于奇点积分，可以通过代换消除奇点。

分治法：

将大规模的计算任务分解为多个小规模的子任务，分别计算后再合并结果。这种方法可以减少舍入误差的累积。

数值分析方法：

使用更高阶的数值方法（如辛普森法、龙贝格积分法）可以提高精度。这些方法通过更精确地近似函数的变化来减少误差。

误差补偿技术：

使用误差补偿技术（如 Kahan 求和算法）可以显著减少舍入误差的影响。

优化算法设计：

在设计算法时，尽量避免将数量级相差较大的数直接相加。例如，可以先对数据进行排序或分组处理。
## 附录：关键代码
```python
import numpy as np
import matplotlib.pyplot as plt

def sum_up(N):
    """从小到大计算调和级数和
    
    参数:
        N (int): 求和项数
        
    返回:
        float: 调和级数和
    """
    # 学生在此实现从小到大求和
    # 提示: 使用循环从1加到N，每次加上1/n
    result = 0.0  # 初始化结果为0
    for n in range(1, N + 1):  # 从1到N逐项累加
        result += 1 / n  # 每次加上1/n
    return result  # 返回最终结果
    pass

def sum_down(N):
    """从大到小计算调和级数和
    
    参数:
        N (int): 求和项数
        
    返回:
        float: 调和级数和
    """
    # 学生在此实现从大到小求和
    # 提示: 使用循环从N减到1，每次加上1/n
    result = 0.0  # 初始化结果为0
    for n in range(N, 0, -1):  # 从N到1逐项累加
        result += 1 / n  # 每次加上1/n
    return result  # 返回最终结果
    pass

def calculate_relative_difference(N):
    """计算两种方法的相对差异
    
    参数:
        N (int): 求和项数
        
    返回:
        float: 相对差异值
    """
    # 学生在此实现相对差异计算
    # 提示: 使用公式 |S_up - S_down| / ((S_up + S_down)/2)
    S_up = sum_up(N)  # 从小到大求和
    S_down = sum_down(N)  # 从大到小求和
    return abs(S_up - S_down) / ((S_up + S_down) / 2)  # 计算相对差异
    pass

def plot_differences():
    """绘制相对差异随N的变化"""
    # 学生在此实现绘图功能
    # 提示:
    # 1. 使用np.logspace生成N值
    # 2. 计算每个N对应的相对差异
    # 3. 使用plt.loglog绘制双对数坐标图
    N_values = np.logspace(1, 6, 50, dtype=int)  # 生成从10到10^6的对数间隔点
    differences = [calculate_relative_difference(N) for N in N_values]  # 计算每个N的相对差异

    plt.figure(figsize=(10, 6))  # 创建图表
    plt.loglog(N_values, differences, 'o-', label="Relative Difference")  # 绘制双对数图
    plt.xlabel("Number of Terms (N)")  # 设置x轴标签
    plt.ylabel("Relative Difference")  # 设置y轴标签
    plt.title("Relative Difference vs N (Harmonic Sum)")  # 设置标题
    plt.grid(True, which="both", linestyle="--")  # 添加网格线
    plt.legend()  # 添加图例
    plt.show()  # 显示图表
    pass

def print_results():
    """打印典型N值的计算结果"""
    # 学生在此实现结果打印
    # 提示:
    # 1. 选择几个典型N值(如10,100,1000,10000)
    # 2. 计算并格式化输出两种方法的和及相对差异
    N_values = [10, 100, 1000, 10000, 100000]  # 选择几个典型的N值
    print(f"{'N':<10}{'S_up':<20}{'S_down':<20}{'Relative Difference':<20}")  # 打印表头
    print("-" * 70)  # 打印分隔线
    for N in N_values:
        S_up = sum_up(N)  # 从小到大求和
        S_down = sum_down(N)  # 从大到小求和
        diff = calculate_relative_difference(N)  # 计算相对差异
        print(f"{N:<10}{S_up:<20.10f}{S_down:<20.10f}{diff:<20.10e}")  # 格式化输出结果
    pass

def main():
    """主函数"""
    # 打印计算结果
    print_results()
    
    # 绘制误差图
    plot_differences()

if __name__ == "__main__":
    main()

```
