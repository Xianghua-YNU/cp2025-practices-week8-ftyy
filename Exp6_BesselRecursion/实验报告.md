# 实验六：球贝塞尔函数的递推关系与数值稳定性实验报告

## 1. 实验目的
1. 实现并比较球贝塞尔函数的向上和向下递推计算方法
2. 理解并掌握向下递推结果的归一化方法
3. 通过实验观察和分析不同递推方法的数值稳定性
4. 深入理解数值计算中的误差放大和抑制机制

## 2. 实验原理
### 2.1 球贝塞尔函数
球贝塞尔函数 $j_l(x)$ 满足二阶线性常微分方程：
$$ x^2 f''(x) + 2xf'(x) + [x^2 - l(l+1)]f(x) = 0 $$

最低阶的两个函数解析形式：
$$ j_0(x) = \frac{\sin x}{x} $$
$$ j_1(x) = \frac{\sin x}{x^2} - \frac{\cos x}{x} $$

### 2.2 递推关系
1. 向上递推：
   $$ j_{l+1}(x) = \frac{2l+1}{x} j_l(x) - j_{l-1}(x) $$

2. 向下递推：
   $$ j_{l-1}(x) = \frac{2l+1}{x} j_l(x) - j_{l+1}(x) $$

### 2.3 归一化方法
向下递推结果的归一化：
$$ j_l^\mathrm{normalized}(x) = j_l^\mathrm{compute}(x) \times \frac{j_0^\mathrm{analytic}(x)}{j_0^\mathrm{compute}(x)} $$

## 3. 实验方法
### 3.1 代码实现
1. `bessel_up(x, lmax)` 函数实现：
初始值选取：使用scipy.special.spherical_jn直接计算j₀(x)和j₁(x)作为初始值
递推过程：从l=1开始，使用向上递推公式逐步计算更高阶的函数值
实现方法：先用spherical_jn计算出初始值，再利用递推公式得出高阶项。特点简单直接，但数值稳定性较差
   

2. `bessel_down(x, lmax, m_start)` 函数实现：
初始值选取：从足够高的m_start开始，设置j[m_start]和j[m_start-1]为任意非零值（这里设为1.0）
递推过程：从m_start向下递推，直到l=0
归一化方法：使用解析的j₀(x)与计算得到的j₀(x)比值作为归一化因子
实现方法：需要额外计算步骤但数值稳定

### 3.2 数据收集与处理
1. 测试点选取：x = 0.1, 1.0, 10.0
2. 计算范围：l = 0 到 25
3. 与scipy.special.spherical_jn比较
4. 误差计算方法

## 4. 实验结果
### 4.1 数值结果
### x = 0.1 时的计算结果

| 阶数 l | 向上递推 (Up)      | 向下递推 (Down)    | Scipy 参考值      |
|-------|-------------------|-------------------|------------------|
| 3     | 9.518520×10⁻⁶     | 9.518520×10⁻⁶     | 9.518520×10⁻⁶    |
| 5     | 1.332813×10⁻⁹     | 9.616310×10⁻¹⁰    | 9.616310×10⁻¹⁰   |
| 8     | 7.960077×10⁻⁴     | 2.901200×10⁻¹⁶    | 2.901200×10⁻¹⁶   |

### x = 1.0 时的计算结果

| 阶数 l | 向上递推 (Up)      | 向下递推 (Down)    | Scipy 参考值      |
|-------|-------------------|-------------------|------------------|
| 3     | 9.006581×10⁻³     | 9.006581×10⁻³     | 9.006581×10⁻³    |
| 5     | 9.256116×10⁻⁵     | 9.256116×10⁻⁵     | 9.256116×10⁻⁵    |
| 8     | 2.876642×10⁻⁸     | 2.826499×10⁻⁸     | 2.826499×10⁻⁸    |

### x = 10.0 时的计算结果

| 阶数 l | 向上递推 (Up)      | 向下递推 (Down)    | Scipy 参考值      |
|-------|-------------------|-------------------|------------------|
| 3     | -3.949584×10⁻²    | -3.949566×10⁻²    | -3.949584×10⁻²   |
| 5     | -5.553451×10⁻²    | -5.553451×10⁻²    | -5.553451×10⁻²   |
| 8     | 1.255780×10⁻¹     | 1.255780×10⁻¹     | 1.255780×10⁻¹    |
### 4.2 误差分析图
![Figure_3](https://github.com/user-attachments/assets/7bcc6a00-a628-4d13-ae78-cdd1d7a1d919)



## 5. 分析与讨论
### 5.1 数值稳定性分析
1. 向上递推的不稳定性：
失效区域：当l > x时，向上递推结果迅速偏离真实值
误差放大机制：递推公式中的(2l+1)/x系数随l增大而增大，导致舍入误差被放大
与球诺伊曼函数的关系：向上递推会混入发散的球诺伊曼函数成分

2. 向下递推的稳定性：
误差抑制机制：向下递推天然压制发散解，保留收敛解
归一化的作用：通过低阶精确值校正整个序列，确保全局精度
计算精度：在合理选择m_start情况下，相对误差可保持在机器精度水平

### 5.2 计算效率比较
1.计算时间：两种方法时间复杂度相同，均为O(lmax)
2.效率因素：向下递推需要额外计算约15项用于稳定，但实际运行时间差异不大
3.精度代价：向下递推需要归一化步骤，但换来了数值稳定性

## 6. 结论
1. 方法适用性：
 向上递推仅适用于l < x的情况
 向下递推适用于所有情况，特别是高l值计算
2. 数值稳定性：
 向上递推在l > x时数值不稳定
 向下递推具有天然的误差抑制特性
3. 归一化作用：
 向下递推通过归一化确保全局精度
 归一化因子基于低阶精确解，保证计算可靠性

## 7. 思考题
1. 为什么向上递推在l > x时会变得不稳定？
当l > x时，递推系数(2l+1)/x变大，放大舍入误差
数值解会混入微分方程的另一个解（球诺伊曼函数）的成分
误差呈指数增长，导致计算结果迅速失真

2. 向下递推为什么能够有效抑制误差？
递推过程天然压制发散解，保留物理相关的收敛解
误差在递推过程中被逐步减小而非放大
归一化步骤进一步保证了整体精度

3. 如何选择合适的m_start值以保证计算精度？
一般取m_start = lmax + 15足够
对于x较大的情况，建议m_start > 1.5x + 15
可通过检查归一化因子的合理性验证m_start是否足够大
## 附录：关键代码
```python
# 在此粘贴关键代码实现
j = np.zeros(lmax + 1)
    # 计算j_0和j_1的初始值
    j[0] = spherical_jn(0, x)
    if lmax > 0:
        j[1] = spherical_jn(1, x)
    # 使用递推公式计算高阶项
    for l in range(1, lmax):
        j[l + 1] = ((2 * l + 1) / x) * j[l] - j[l - 1]
    return j

if m_start is None:
        m_start = lmax + 15  # 设置足够高的起始阶数
    # 初始化临时数组并设置初始值
    j_temp = np.zeros(m_start + 1)
    j_temp[m_start] = 1.0  # 任意非零值
    j_temp[m_start - 1] = 1.0  # 任意非零值
    # 使用递推公式向下计算
    for m in range(m_start - 1, 0, -1):
        j_temp[m - 1] = ((2 * m + 1) / x) * j_temp[m] - j_temp[m + 1]
    # 使用j_0(x)进行归一化
    scale_factor = spherical_jn(0, x) / j_temp[0]
    j = j_temp[:lmax + 1] * scale_factor
    return j

lmax = 25
    x_values = [0.1, 1.0, 10.0]
    
    # 对每个x值进行计算和绘图
    for x in x_values:
        plot_comparison(x, lmax)
        
        # 打印特定阶数的结果
        l_check = [3, 5, 8]
        print(f"\nx = {x}:")
        print("l\tUp\t\tDown\t\tScipy")
        print("-" * 50)
        for l in l_check:
            j_up = bessel_up(x, l)[l]
            j_down = bessel_down(x, l)[l]
            j_scipy = spherical_jn(l, x)
            print(f"{l}\t{j_up:.6e}\t{j_down:.6e}\t{j_scipy:.6e}")
```
